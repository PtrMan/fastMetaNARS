module fastMetaNars.deriver.DeriverCaller;

import std.array : array;
import std.algorithm.iteration : filter;

import fastMetaNars.FlagsOfCopulaComplexity;
import fastMetaNars.ReasonerInstance;
import fastMetaNars.deriver.DeriverUtils;

// generated by codegenerator
import fastMetaNars.autogenerated.Deriver;

// - calls deriver
// - checks if the termcomplexity is too large, if so its thrown away
// - for each remaining derivation result insert and translate to compounds and termTuples
// - for each remaining derivation result insert to concepts
void deriverCaller(ReasonerInstance reasonerInstance, UnifiedTermIndex premiseLeftIndex, UnifiedTermIndex premiseRightIndex, bool insert = true) {
	/* still in here because it shows how to recalculate complexity recursivly
	uint recalcTermComplexityRecursive(TemporaryDerivedCompound* derivedCompound) {
		uint getTermComplexityOfLeaf() {
			assert( derivedCompound.isLeaf );
			return reasonerInstance.getTermComplexityOfAndByTermReferer(derivedCompound.termReferer);
		}

		if( derivedCompound.isLeaf ) {
			return derivedCompound.termComplexity = getTermComplexityOfLeaf();
		}
		else if( derivedCompound )
		else {
			derivedCompound.termComplexity = getComplexityOfFlagsOfCopula(derivedCompound.flagsOfCopula);

			// TODO< implement for nonbinary >
			assert(derivedCompound.leftChildren !is null);
			assert(derivedCompound.rightChildren !is null);
			derivedCompound.termComplexity += recalcTermComplexityRecursive(derivedCompound.leftChildren);
			derivedCompound.termComplexity += recalcTermComplexityRecursive(derivedCompound.rightChildren);

			return derivedCompound.termComplexity;
		}
	}
	*/

	TemporaryDerivedTerm*[] temporaryDerivedTerms = derive(reasonerInstance, premiseLeftIndex, premiseRightIndex);
	foreach( iterationTemporaryDerivedTerms; temporaryDerivedTerms ) {
		// TODO< optimize this by storing the termcomplexity into the TemporaryDerivedTerm in the method ! >
		iterationTemporaryDerivedTerms.derivedCompound.termComplexity = iterationTemporaryDerivedTerms.derivedCompound.calcComplexityRecursive(reasonerInstance);

		// recalcTermComplexityRecursive(iterationTemporaryDerivedTerms.derivedCompound);
	}

	// filter by maximal term complexity
	auto filteredTerms = temporaryDerivedTerms.filter!(a => a.derivedCompound.termComplexity <= reasonerInstance.configuration.maximalTermComplexity);

	// debug
	// for now we just dump the TemporaryDerivedCompounds and the compounds they reference
	debugTermsToConsole(reasonerInstance, filteredTerms.array);

	if( insert ) {
		// insert and translate to compounds and termTuples
		assert(false, "TODO");
	}
}

// debugging
// ===

import std.format : format;
import std.conv : to;
import std.stdio : writeln;

private void debugTermsToConsole(ReasonerInstance reasonerInstance, TemporaryDerivedTerm*[] terms) {
	string message;
	foreach( iterationTerm; terms ) {
		message ~= "derived term = (%s)\n".format(iterationTerm.dumpToString(reasonerInstance));
	}

	writeln(message);
}

private string dumpToString(TemporaryDerivedTerm* derivedTerm, ReasonerInstance reasonerInstance) {
	return "%s truthfn=%s".format(derivedTerm.derivedCompound.debugToStringRecursivly(reasonerInstance), derivedTerm.truthfunction.to!string);
}
