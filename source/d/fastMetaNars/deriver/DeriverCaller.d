module fastMetaNars.deriver.DeriverCaller;

import std.array : array;
import std.algorithm.iteration : filter, map;
import std.stdint;

import fastMetaNars.FlagsOfCopulaComplexity;
import fastMetaNars.ReasonerInstance;
import fastMetaNars.deriver.DeriverUtils;
import fastMetaNars.Term;
import fastMetaNars.TermOrCompoundTermOrVariableReferer;

// generated by codegenerator
import fastMetaNars.autogenerated.Deriver;

// - calls deriver
// - checks if the termcomplexity is too large, if so its thrown away
// - for each remaining derivation result insert and translate to compounds and termTuples
// - for each remaining derivation result insert to concepts
void deriverCaller(ReasonerInstance reasonerInstance, UnifiedTermIndex premiseLeftIndex, UnifiedTermIndex premiseRightIndex, bool insert = true) {
	/* still in here because it shows how to recalculate complexity recursivly
	uint recalcTermComplexityRecursive(TemporaryDerivedCompound* derivedCompound) {
		uint getTermComplexityOfLeaf() {
			assert( derivedCompound.isLeaf );
			return reasonerInstance.getTermComplexityOfAndByTermReferer(derivedCompound.termReferer);
		}

		if( derivedCompound.isLeaf ) {
			return derivedCompound.termComplexity = getTermComplexityOfLeaf();
		}
		else if( derivedCompound )
		else {
			derivedCompound.termComplexity = getComplexityOfFlagsOfCopula(derivedCompound.flagsOfCopula);

			// TODO< implement for nonbinary >
			assert(derivedCompound.leftChildren !is null);
			assert(derivedCompound.rightChildren !is null);
			derivedCompound.termComplexity += recalcTermComplexityRecursive(derivedCompound.leftChildren);
			derivedCompound.termComplexity += recalcTermComplexityRecursive(derivedCompound.rightChildren);

			return derivedCompound.termComplexity;
		}
	}
	*/

	TemporaryDerivedTerm*[] temporaryDerivedTerms = derive(reasonerInstance, premiseLeftIndex, premiseRightIndex);
	foreach( iterationTemporaryDerivedTerms; temporaryDerivedTerms ) {
		// TODO< optimize this by storing the termcomplexity into the TemporaryDerivedTerm in the method ! >
		iterationTemporaryDerivedTerms.derivedCompound.termComplexity = iterationTemporaryDerivedTerms.derivedCompound.calcComplexityRecursive(reasonerInstance);

		// recalcTermComplexityRecursive(iterationTemporaryDerivedTerms.derivedCompound);
	}

	// filter by maximal term complexity
	auto filteredTerms = temporaryDerivedTerms.filter!(a => a.derivedCompound.termComplexity <= reasonerInstance.configuration.maximalTermComplexity);

	// debug
	// for now we just dump the TemporaryDerivedCompounds and the compounds they reference
	debugTermsToConsole(reasonerInstance, filteredTerms.array);

	if( insert ) {
		// insert and translate to compounds and termTuples
		insertDerivedCompoundTerms(reasonerInstance, filteredTerms.array);
	}
}

void insertDerivedCompoundTerms(ReasonerInstance reasonerInstance, TemporaryDerivedTerm*[] derivedCompoundTerms) {
	foreach( iterationDerivedCompoundTerm; derivedCompoundTerms.map!(v => v.derivedCompound) ) {
		insertDerivedCompoundTerm(reasonerInstance, TemporaryDerivedCompoundDecoration.makeRecursive(iterationDerivedCompoundTerm));
	}
}

void insertDerivedCompoundTerm(ReasonerInstance reasonerInstance, TemporaryDerivedCompoundWithDecoration *derivedCompoundTerm) {
	// TODO< good place to hook in (compound)term compression >


	// the index of the compound in the compound table is returned with the decoration of the argument "derivedCompoundTerm"
	void innerFnInsertIfItDoesntExistRecursivly(TemporaryDerivedCompoundWithDecoration *derivedCompoundTerm) {
		// recurse to children
		if( derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.COMPOUND ) {
			innerFnInsertIfItDoesntExistRecursivly(derivedCompoundTerm.leftChildren);
			innerFnInsertIfItDoesntExistRecursivly(derivedCompoundTerm.rightChildren);
		}

		// create if not exist

		if( derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.COMPOUND ) { // is a Temporary compound(term)
			bool innerFnEarlyTestExistsCompound() {
				return reasonerInstance.existTermTuple([derivedCompoundTerm.leftChildren, derivedCompoundTerm.rightChildren].map!(n => reasonerInstance.getCompoundByIndex(n.decoration.compoundIndex).thisTermReferer).array);
			}

			// returns compoundIndex
			size_t innerFnCreateCompoundAndAddToReasoner(size_t termTupleIndex) {
				// create compound
				size_t compoundIndex = reasonerInstance.getCompoundCreateIndex(); // get the index where the compound will be created

				Compound.MakeParameters compoundMakeParameters;
				compoundMakeParameters.termComplexity = derivedCompoundTerm.termComplexity;
				compoundMakeParameters.flagsOfCopula = derivedCompoundTerm.flagsOfCopula;
				compoundMakeParameters.thisTermReferer = TermOrCompoundTermOrVariableReferer.makeNonatomic(compoundIndex); // create new referer based on the compound index
				compoundMakeParameters.termTupleIndex = termTupleIndex;

				Compound createdCompound = reasonerInstance.createCompound(compoundMakeParameters);
				
				// insert compound
				reasonerInstance.addCompound(createdCompound);

				return compoundIndex;
			}



			// build the term, calculate the hash, try to lookup the compound based on the hash
			// if it exists we return the compoundIndex of the found compound
			// if it doesn't exist we create a new Compound and return it

			if( innerFnEarlyTestExistsCompound() ) { // if the term tuple exists then the compound could exist
				// build compound and calc hash and try to look it up and compare it to the built compound


				size_t termTupleIndex = reasonerInstance.getTermTupleIndexByReferers([derivedCompoundTerm.leftChildren, derivedCompoundTerm.rightChildren].map!(n => reasonerInstance.getCompoundByIndex(n.decoration.compoundIndex).thisTermReferer).array);

				//   * build compound
				Compound.MakeParameters compoundMakeParameters;
				compoundMakeParameters.termComplexity = derivedCompoundTerm.termComplexity;
				compoundMakeParameters.flagsOfCopula = derivedCompoundTerm.flagsOfCopula;

				//compoundMakeParameters.compoundId;      we don't need to initialize it because the hash computation for this lookup doesn't use it
				//                                        the hash computation doesn't use it because we don't know it

				//compoundMakeParameters.thisTermReferer  we don't need to intialize it because it's not used for hash computation
				compoundMakeParameters.termTupleIndex = termTupleIndex;
				Compound createdCompoundForHash = Compound.make(compoundMakeParameters);
				//   * calc hash
				createdCompoundForHash.updateHash(/*with compoundId*/false);

				//    * lookup hash and compare if possible
				//      if the compound doesn't exist we create and add it
				size_t compoundIndex;
				if( reasonerInstance.compoundExistsWithoutCompoundId(createdCompoundForHash, /*out*/compoundIndex) ) {
					// set as the result the compound
					derivedCompoundTerm.decoration.compoundIndex = compoundIndex;
				}
				else {
					// create and add compound
					compoundIndex = innerFnCreateCompoundAndAddToReasoner(termTupleIndex);

					// set as the result the compound
					derivedCompoundTerm.decoration.compoundIndex = compoundIndex;
				}
			}
			else { // if the term tuple doesn't exist then the compound can't exist so we have to create and return it
				// create termTuple
				size_t termTupleIndex = reasonerInstance.addTermTupleByReferers([derivedCompoundTerm.leftChildren, derivedCompoundTerm.rightChildren].map!(n => reasonerInstance.getCompoundByIndex(n.decoration.compoundIndex).thisTermReferer).array);
				// create and add compound
				size_t compoundIndex = innerFnCreateCompoundAndAddToReasoner(termTupleIndex);

				// set as the result the compound
				derivedCompoundTerm.decoration.compoundIndex = compoundIndex;
			}
		}
		else if(
			derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.LEAF ||
			derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.INDEPENDENTVARIABLE ||
			derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.DEPENDENTVARIABLE
		) {
			Compound.CompoundIdType compoundId;

			if( derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.LEAF ) {
				TermOrCompoundTermOrVariableReferer termReferer = derivedCompoundTerm.termReferer;
				compoundId = termReferer.getMaskedOutId; // a single term is a (compound)term too
			}
			else if( derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.INDEPENDENTVARIABLE ) {
				compoundId = derivedCompoundTerm.independentVariableId; // ASSUMPTION< compoundId is the id of the variable >
			}
			else if( derivedCompoundTerm.type == TemporaryDerivedCompound.EnumType.DEPENDENTVARIABLE ) {
				compoundId = derivedCompoundTerm.dependentVariableId; // ASSUMPTION< compoundId is the id of the variable >
			}
			else {
				throw new Exception("Internal error");
			}

			size_t compoundIndex = reasonerInstance.translateCompoundIdToCompoundIndex(compoundId);

			derivedCompoundTerm.decoration.compoundIndex = compoundIndex;
		}
		else {
			throw new Exception("Internal error");
		}
	}
	// for now we just check for the existence and insert it recursivly
	innerFnInsertIfItDoesntExistRecursivly(derivedCompoundTerm);
}

// debugging
// ===

import std.format : format;
import std.conv : to;
import std.stdio : writeln;

private void debugTermsToConsole(ReasonerInstance reasonerInstance, TemporaryDerivedTerm*[] terms) {
	string message;
	foreach( iterationTerm; terms ) {
		message ~= "derived term = (%s)\n".format(iterationTerm.dumpToString(reasonerInstance));
	}

	writeln(message);
}

private string dumpToString(TemporaryDerivedTerm* derivedTerm, ReasonerInstance reasonerInstance) {
	return "%s truthfn=%s".format(derivedTerm.derivedCompound.debugToStringRecursivly(reasonerInstance), derivedTerm.truthfunction.to!string);
}
