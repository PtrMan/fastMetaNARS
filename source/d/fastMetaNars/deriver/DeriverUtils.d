module fastMetaNars.deriver.DeriverUtils;

import std.format : format;

import fastMetaNars.ReasonerInstance;
import fastMetaNars.FlagsOfCopula;
import fastMetaNars.FlagsOfCopulaConvertToString;
import fastMetaNars.FlagsOfCopulaComplexity;
import fastMetaNars.TermReferer;
import fastMetaNars.RuleTable;
import fastMetaNars.Term;

struct TemporaryDerivedCompound {
	enum EnumType {
		COMPOUND,
		LEAF,
		INDEPENDENTVARIABLE,
		DEPENDENTVARIABLE,
	}

	static TemporaryDerivedCompound* makeBinaryCompound(FlagsOfCopula flagsOfCopula, TemporaryDerivedCompound* leftChildren, TemporaryDerivedCompound* rightChildren) {
		TemporaryDerivedCompound* result = new TemporaryDerivedCompound;
		result.flagsOfCopula = flagsOfCopula;
		result.leftChildren = leftChildren;
		result.rightChildren = rightChildren;
		result.type = EnumType.COMPOUND;
		return result;
	}

	static TemporaryDerivedCompound* makeLeaf(TermReferer termReferer) {
		TemporaryDerivedCompound* result = new TemporaryDerivedCompound;
		result.protectedTermReferer = termReferer;
		result.type = EnumType.LEAF;
		return result;
	}

	static TemporaryDerivedCompound* makeReferenceIndependentVariable(uint id) {
		TemporaryDerivedCompound* result = new TemporaryDerivedCompound;
		with(result) {
			protectedVariableId = id;
			type = EnumType.INDEPENDENTVARIABLE;
		}
		return result;
	}

	static TemporaryDerivedCompound* makeReferenceDependentVariable(uint id) {
		TemporaryDerivedCompound* result = new TemporaryDerivedCompound;
		with(result) {
			protectedVariableId = id;
			type = EnumType.DEPENDENTVARIABLE;
		}
		return result;
	}


	final @property bool isLeaf() pure {
		return type == EnumType.LEAF;
	}

	final string debugToStringRecursivly(ReasonerInstance reasonerInstance) {
		if( isLeaf ) {
			return "<LEAF=%s>".format(reasonerInstance.getDebugStringByTermReferer(termReferer));
		}
		else if( isIndependentVariable ) {
			return "<$VAR:%s>".format(independentVariableId);
		}
		else if( isDependentVariable ) {
			return "<#VAR:%s>".format(dependentVariableId);
		}
		else {
			// TODO< implement for nonbinary >
			return "<COMPOUND=%s %s %s>".format(leftChildren.debugToStringRecursivly(reasonerInstance), flagsOfCopula.convToHumanString(), rightChildren.debugToStringRecursivly(reasonerInstance));
		}
	}

	final uint calcComplexityRecursive(ReasonerInstance reasonerInstance) {
		if( isLeaf ) {
			return reasonerInstance.getTermComplexityOfAndByTermReferer(termReferer);
		}
		else if( isIndependentVariable ) {
			return Compound.COMPLEXITYINDEPENDENTVARIABLE;
		}
		else if( isDependentVariable ) {
			return Compound.COMPLEXITYDEPENDENTVARIABLE;
		}
		else {
			uint complexity = getComplexityOfFlagsOfCopula(flagsOfCopula);

			// TODO< implement for nonbinary >
			complexity += leftChildren.calcComplexityRecursive(reasonerInstance);
			complexity += rightChildren.calcComplexityRecursive(reasonerInstance);
			return complexity;
		}
	}

	EnumType type;
	FlagsOfCopula flagsOfCopula; // TODO< accessor >
	TemporaryDerivedCompound* leftChildren; // TODO< accessor >
	TemporaryDerivedCompound* rightChildren; // TODO< accessor >

	final @property TermReferer termReferer() pure {
		assert(type == EnumType.LEAF);
		return protectedTermReferer;
	}

	final @property uint independentVariableId() pure {
		assert(type == EnumType.INDEPENDENTVARIABLE);
		return protectedVariableId;
	}

	final @property uint dependentVariableId() pure {
		assert(type == EnumType.DEPENDENTVARIABLE);
		return protectedVariableId;
	}

	final @property bool isIndependentVariable() pure {
		return type == EnumType.INDEPENDENTVARIABLE;
	}

	final @property bool isDependentVariable() pure {
		return type == EnumType.DEPENDENTVARIABLE;
	}

	final @property bool isVariable() pure {
		return isIndependentVariable || isDependentVariable;
	}


	uint termComplexity;

	protected TermReferer protectedTermReferer;

	protected uint protectedVariableId;
}

// utilities used by the autogenerated deriver

TemporaryDerivedCompound* genBinary(FlagsOfCopula flagsOfCopula, TemporaryDerivedCompound* left, TemporaryDerivedCompound* right) {
	return TemporaryDerivedCompound.makeBinaryCompound(flagsOfCopula, left, right);
}

TemporaryDerivedCompound* genBinary(FlagsOfCopula flagsOfCopula, TemporaryDerivedCompound* left, TermReferer termRefererRight) {
	return TemporaryDerivedCompound.makeBinaryCompound(flagsOfCopula, left, TemporaryDerivedCompound.makeLeaf(termRefererRight));
}

TemporaryDerivedCompound* genBinary(FlagsOfCopula flagsOfCopula, TermReferer termRefererLeft, TemporaryDerivedCompound* right) {
	return TemporaryDerivedCompound.makeBinaryCompound(flagsOfCopula, TemporaryDerivedCompound.makeLeaf(termRefererLeft), right);
}

TemporaryDerivedCompound* genBinary(FlagsOfCopula flagsOfCopula, TermReferer termRefererLeft, TermReferer termRefererRight) {
	return TemporaryDerivedCompound.makeBinaryCompound(flagsOfCopula, TemporaryDerivedCompound.makeLeaf(termRefererLeft), TemporaryDerivedCompound.makeLeaf(termRefererRight));
}

TemporaryDerivedCompound* makeReferenceIndependentVariable(uint id) {
	return TemporaryDerivedCompound.makeReferenceIndependentVariable(id);
}

TemporaryDerivedCompound* makeReferenceDependentVariable(uint id) {
	return TemporaryDerivedCompound.makeReferenceDependentVariable(id);
}


struct TemporaryDerivedTerm {
	TemporaryDerivedCompound* derivedCompound;
	RuleTable.EnumTruthFunction truthfunction;
}

TemporaryDerivedTerm* genTerm(TemporaryDerivedCompound* derivedCompound, RuleTable.EnumTruthFunction truthfunction) {
	TemporaryDerivedTerm* result = new TemporaryDerivedTerm;
	result.derivedCompound = derivedCompound;
	result.truthfunction = truthfunction;
	return result;
}
